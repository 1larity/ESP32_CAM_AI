## Prompt for Copilot
```
(no prompt provided)
```
# Packaged Project (C/C++)
- **Project root**: C:\Users\stellaris\Documents\PlatformIO\Projects\ESP32_CAM_AI\src
- **Generated**: 2025-11-09 22:55:54 +0000
- **Tool**: Copilot Python Packager v1.6
## Table of contents
- `CameraServer.cpp`
- `CameraServer.h`
- `main.cpp`
- `OTAHandler.cpp`
- `OTAHandler.h`
- `PTZ.cpp`
- `PTZ.h`
- `StreamServer.cpp`
- `StreamServer.h`
- `Utils.cpp`
- `Utils.h`
- `WiFiConfigPortal.cpp`
- `WiFiManager.cpp`
- `WiFiManager.h`
---
## `CameraServer.cpp`
**Absolute path**: C:\Users\stellaris\Documents\PlatformIO\Projects\ESP32_CAM_AI\src\CameraServer.cpp
**Size**: 9076 bytes
**Modified**: 2025-11-09 15:48:14 +0000
**SHA256**: 275b164274ce314efee15025331724f940679d93d5a38b8422d55139976d7b5e
``````cpp// CameraServer.cpp
#include "WiFiManager.h"
#include "CameraServer.h"
#include "OTAHandler.h"
#include "esp_camera.h"
#include <WiFi.h>
#include <ESPAsyncWebServer.h>
#include <Preferences.h>
#include "StreamServer.h"
#include "PTZ.h"

// ===== Resolution options with actual pixel sizes =====
struct ResolutionOption {
  framesize_t size;
  const char* name;
  uint16_t    w;
  uint16_t    h;
};
static Preferences camPrefs;
static const char* CAM_NS  = "camera";
static const char* KEY_RES = "res";

static const ResolutionOption resolutionOptions[] = {
  {FRAMESIZE_UXGA,  "UXGA",   1600,1200},
  {FRAMESIZE_SXGA,  "SXGA",   1280,1024},
  {FRAMESIZE_XGA,   "XGA",    1024,768},
  {FRAMESIZE_SVGA,  "SVGA",   800, 600},
  {FRAMESIZE_VGA,   "VGA",    640, 480},
  {FRAMESIZE_CIF,   "CIF",    352, 288},
  {FRAMESIZE_QVGA,  "QVGA",   320, 240},
  {FRAMESIZE_HQVGA, "HQVGA",  240, 176},
  {FRAMESIZE_QQVGA, "QQVGA",  160, 120},
};
// AI Thinker pin map
#define PWDN_GPIO_NUM     32
#define RESET_GPIO_NUM    -1
#define XCLK_GPIO_NUM      0
#define SIOD_GPIO_NUM     26
#define SIOC_GPIO_NUM     27

#define Y9_GPIO_NUM       35
#define Y8_GPIO_NUM       34
#define Y7_GPIO_NUM       39
#define Y6_GPIO_NUM       36
#define Y5_GPIO_NUM       21
#define Y4_GPIO_NUM       19
#define Y3_GPIO_NUM       18
#define Y2_GPIO_NUM        5
#define VSYNC_GPIO_NUM    25
#define HREF_GPIO_NUM     23
#define PCLK_GPIO_NUM     22

void setupCamera() {
  camera_config_t config = {};
  config.ledc_channel = LEDC_CHANNEL_0;
  config.ledc_timer   = LEDC_TIMER_0;
  config.pin_d0       = Y2_GPIO_NUM;
  config.pin_d1       = Y3_GPIO_NUM;
  config.pin_d2       = Y4_GPIO_NUM;
  config.pin_d3       = Y5_GPIO_NUM;
  config.pin_d4       = Y6_GPIO_NUM;
  config.pin_d5       = Y7_GPIO_NUM;
  config.pin_d6       = Y8_GPIO_NUM;
  config.pin_d7       = Y9_GPIO_NUM;
  config.pin_xclk     = XCLK_GPIO_NUM;
  config.pin_pclk     = PCLK_GPIO_NUM;
  config.pin_vsync    = VSYNC_GPIO_NUM;
  config.pin_href     = HREF_GPIO_NUM;
  config.pin_sccb_sda = SIOD_GPIO_NUM;
  config.pin_sccb_scl = SIOC_GPIO_NUM;
  config.pin_pwdn     = PWDN_GPIO_NUM;
  config.pin_reset    = RESET_GPIO_NUM;
  config.xclk_freq_hz = 20000000;
  config.pixel_format = PIXFORMAT_JPEG;

  // PSRAM tuning
  if (psramFound()) {
    config.frame_size   = FRAMESIZE_VGA; // will override below from prefs
    config.jpeg_quality = 12;            // lower = better quality
    config.fb_count     = 2;
    config.grab_mode    = CAMERA_GRAB_LATEST;
  } else {
    config.frame_size   = FRAMESIZE_QVGA;
    config.jpeg_quality = 15;
    config.fb_count     = 1;
  }

  // Init camera
  esp_err_t err = esp_camera_init(&config);
  if (err != ESP_OK) {
    Serial.printf("Camera init failed: 0x%X\n", err);
    return;
  }

  // Apply persisted framesize if present
  framesize_t fs = config.frame_size;
  camPrefs.begin(CAM_NS, true);
  if (camPrefs.isKey(KEY_RES)) {
    fs = (framesize_t)camPrefs.getUChar(KEY_RES, (uint8_t)config.frame_size);
  }
  camPrefs.end();

  sensor_t* s = esp_camera_sensor_get();
  if (s) s->set_framesize(s, fs);

  // Start port-81 MJPEG stream server
  startStreamServer();

  Serial.println("Camera ready");
}
static inline const ResolutionOption* findByName(const String& n) {
  for (auto& o : resolutionOptions) if (n.equalsIgnoreCase(o.name)) return &o;
  return nullptr;
}

static const char* kStyle = R"CSS(
  <style>
    :root{
      --bg:#eaf4ff; --panel:#ffffff; --text:#102a43; --muted:#486581; --accent:#2b6cb0;
      --line:#cfe3ff; --shadow:0 1px 4px rgba(16,42,67,.08);
    }
    *{box-sizing:border-box}
    html,body{margin:0;padding:0;background:var(--bg);color:var(--text);
      font-family:system-ui,-apple-system,"Segoe UI",Roboto,Ubuntu,"Helvetica Neue",Arial,sans-serif}
    .wrap{max-width:980px;margin:20px auto;padding:0 12px}
    .nav{display:flex;gap:8px;justify-content:flex-end;margin:6px 0 16px 0}
    .btn{appearance:none;border:1px solid var(--line);padding:8px 12px;border-radius:8px;
      background:#d9ebff;cursor:pointer;font-weight:600;box-shadow:var(--shadow);text-decoration:none;color:inherit}
    .btn:hover{background:#cfe3ff}
    .panel{background:var(--panel);border:1px solid var(--line);border-radius:12px;
      box-shadow:var(--shadow);padding:14px 14px 16px 14px;margin:14px 0}
    .panel h3{margin:0 0 10px 0;color:var(--accent)}
    .row{margin:8px 0}
    select,button{font-size:1rem;padding:6px 10px;border-radius:8px;border:1px solid var(--line)}
    img.stream{max-width:100%;height:auto;border:1px solid var(--line);border-radius:10px}
    pre{background:#f7fbff;border:1px solid var(--line);border-radius:8px;padding:8px;display:block}
    label{color:var(--muted);margin-right:6px}
  </style>
)CSS";

static void send401(AsyncWebServerRequest* req) {
  auto* r = req->beginResponse(401, "text/plain", "Unauthorized");
  r->addHeader("WWW-Authenticate", "Basic realm=\"ESP32Cam\"");
  req->send(r);
}

static void renderCameraPage(AsyncWebServerRequest* request) {
  sensor_t* s = esp_camera_sensor_get();
  framesize_t cur = s ? s->status.framesize : FRAMESIZE_VGA;

  String html;
  html.reserve(7000);
  html += "<!doctype html><html><head><meta charset='utf-8'><title>ESP32-CAM</title>";
  html += kStyle;
  html += "</head><body><div class='wrap'>";

  html += "<div class='nav'>"
          "<a class='btn' href='/wifi'>Wi-Fi Settings</a>"
          "<a class='btn' href='/ptz/home'>PTZ Home</a>"
          "</div>";

  // Controls
  html += "<div class='panel'><h3>Camera Controls</h3>";
  html += "<div class='row'><label for='res'>Resolution</label>"
          "<select id='res' onchange=\"fetch('/resolution?set='+this.value).then(()=>location.reload())\">";
  for (auto& o : resolutionOptions) {
    bool sel = (s && o.size == cur);
    html += String("<option value='") + o.name + "'" + (sel ? " selected" : "") + ">"
          + o.name + " (" + o.w + "&times;" + o.h + ")</option>";
  }
  html += "</select></div>";

  // PTZ buttons call /ptz/step
  html += "<div class='row'>"
          "<button class='btn' onclick=\"fetch('/ptz/step?dy=10')\">Up</button> "
          "<button class='btn' onclick=\"fetch('/ptz/step?dy=-10')\">Down</button> "
          "<button class='btn' onclick=\"fetch('/ptz/step?dx=-10')\">Left</button> "
          "<button class='btn' onclick=\"fetch('/ptz/step?dx=10')\">Right</button>"
          "</div>";
  html += "</div>";

  // Live video
  html += "<div class='panel'><h3>Live Video</h3>";
  String streamURL = String("http://") + WiFi.localIP().toString() + ":81/stream";
  if (isAuthEnabled()) {
    String tok = getAuthTokenParam();
    if (tok.length() > 0) streamURL += "?token=" + tok;
  }
  html += "<img class='stream' src='" + streamURL + "' alt='Video stream'>";
  html += "</div>";

  // Status block
  html += "<div class='panel'><h3>Status</h3><pre id='st'>Loading…</pre></div>"
          "<script>fetch('/api/status').then(r=>r.json()).then(j=>{"
          "document.getElementById('st').textContent=JSON.stringify(j,null,2);});</script>";

  html += "</div></body></html>";
  request->send(200, "text/html", html);
}

void startCameraServer() {
  AsyncWebServer& srv = getWebServer();

  srv.on("/", HTTP_GET, [](AsyncWebServerRequest *req){
    if (!isAuthorized(req)) { send401(req); return; }
    renderCameraPage(req);
  });
  srv.on("/cam", HTTP_GET, [](AsyncWebServerRequest *req){
    if (!isAuthorized(req)) { send401(req); return; }
    renderCameraPage(req);
  });

  // Change resolution and persist
  srv.on("/resolution", HTTP_GET, [](AsyncWebServerRequest *req){
    if (!isAuthorized(req)) { send401(req); return; }
    if (!req->hasParam("set")) { req->send(400, "text/plain", "Missing ?set="); return; }
    const String target = req->getParam("set")->value();
    const auto* opt = findByName(target);
    if (!opt) { req->send(400, "text/plain", "Invalid resolution"); return; }

    sensor_t* s = esp_camera_sensor_get();
    if (!s) { req->send(500, "text/plain", "Sensor unavailable"); return; }
    s->set_framesize(s, opt->size);

    Preferences camPrefs; camPrefs.begin("camera", false);
    camPrefs.putUChar("res", static_cast<uint8_t>(opt->size));
    camPrefs.end();

    req->send(200, "text/plain", "OK");
  });

  // Composite status JSON for page
  srv.on("/api/status", HTTP_GET, [](AsyncWebServerRequest* req){
    if (!isAuthorized(req)) { send401(req); return; }
    sensor_t* s = esp_camera_sensor_get();
    framesize_t fs = s ? s->status.framesize : FRAMESIZE_VGA;
    int pan=0, tilt=0; ptzGet(pan, tilt);

    char buf[256];
    snprintf(buf, sizeof(buf),
      "{"
      "\"ip\":\"%s\","
      "\"framesize\":%d,"
      "\"ptz\":{\"pan\":%d,\"tilt\":%d}"
      "}",
      WiFi.localIP().toString().c_str(),
      (int)fs, pan, tilt);
    req->send(200, "application/json", buf);
  });
}
## `CameraServer.h`
**Absolute path**: C:\Users\stellaris\Documents\PlatformIO\Projects\ESP32_CAM_AI\src\CameraServer.h
**Size**: 245 bytes
**Modified**: 2025-11-09 15:48:14 +0000
**SHA256**: 848b618bb54a0f163c34e84f7b3bfa22c6202a06301bffc4280278cda472eba9
``````c#ifndef CAMERA_SERVER_H
#define CAMERA_SERVER_H

// Configures camera hardware, PSRAM settings, and servo motors
void setupCamera();

// Launches the web interface for streaming and controlling servos
void startCameraServer();

#endif
## `main.cpp`
**Absolute path**: C:\Users\stellaris\Documents\PlatformIO\Projects\ESP32_CAM_AI\src\main.cpp
**Size**: 1095 bytes
**Modified**: 2025-11-09 22:26:44 +0000
**SHA256**: d97db26f9aa5bdeab26c5a98063662f99cb7e689f7be60f49d2d6c15c3f99aad
``````cpp// esp32cam_main.cpp
#include "Arduino.h"
#include "WiFiManager.h"
#include "CameraServer.h"
#include "OTAHandler.h"
#include "Utils.h"
#include "PTZ.h"  

static bool g_inConfigPortal = false;
static bool g_otaReady = false;

void setup() {
  Serial.begin(115200);
  delay(2000);
  Serial.println("\nBooting ESP32_CAM_AI...");
  disableBrownout();
  Serial.println("Brownout disabled");

  Serial.println("Connecting to stored WiFi...");
  if (!connectToStoredWiFi()) {
    g_inConfigPortal = true;
    Serial.println("No stored WiFi, starting config portal");
    startConfigPortal();
    Serial.println("Config portal started");
    return;
  }
  Serial.println("WiFi connected");

  Serial.println("Init camera...");
  setupCamera();
  Serial.println("Init PTZ...");
  ptzInit();
  Serial.println("Start camera server...");
  startCameraServer();

  Serial.println("Init OTA...");
  setupOTA();
  g_otaReady = true;
  Serial.println("Setup complete");
}

void loop() {
  if (!g_inConfigPortal) {
    if (g_otaReady) {
      handleOTA();
  }}
}
## `OTAHandler.cpp`
**Absolute path**: C:\Users\stellaris\Documents\PlatformIO\Projects\ESP32_CAM_AI\src\OTAHandler.cpp
**Size**: 1504 bytes
**Modified**: 2025-11-09 15:48:14 +0000
**SHA256**: 3e1f96244885de5edccd59653bdae67ba2d045feb634bf7f4e5eb4e1d9a9860f
``````cpp#include <ArduinoOTA.h>
#include <WiFi.h>
#include "esp_camera.h" // Needed for esp_camera_deinit()

void setupOTA() {
  // Set the device name for OTA updates
  ArduinoOTA.setHostname("ESP32Cam");

  // Called when the OTA update starts
  ArduinoOTA.onStart([]() {
    // Deinit camera right before OTA begins to avoid memory/camera conflicts
    esp_camera_deinit();
    String type = ArduinoOTA.getCommand() == U_FLASH ? "sketch" : "filesystem";
    Serial.println("Start updating " + type);
  });

  // Called when the OTA update finishes
  ArduinoOTA.onEnd([]() {
    Serial.println("\nUpdate complete.");
  });

  // Report OTA update progress
  ArduinoOTA.onProgress([](unsigned int progress, unsigned int total) {
    Serial.printf("Progress: %u%%\r", (progress * 100) / total);
  });

  // Handle OTA update errors
  ArduinoOTA.onError([](ota_error_t error) {
    Serial.printf("Error[%u]: ", error);
    if (error == OTA_AUTH_ERROR) Serial.println("Auth Failed");
    else if (error == OTA_BEGIN_ERROR) Serial.println("Begin Failed");
    else if (error == OTA_CONNECT_ERROR) Serial.println("Connect Failed");
    else if (error == OTA_RECEIVE_ERROR) Serial.println("Receive Failed");
    else if (error == OTA_END_ERROR) Serial.println("End Failed");
  });

  // Start OTA service
  ArduinoOTA.begin();
  Serial.println("OTA Ready");
  Serial.print("IP address: ");
  Serial.println(WiFi.localIP());
}

void handleOTA() {
  ArduinoOTA.handle();
}
## `OTAHandler.h`
**Absolute path**: C:\Users\stellaris\Documents\PlatformIO\Projects\ESP32_CAM_AI\src\OTAHandler.h
**Size**: 160 bytes
**Modified**: 2025-11-09 15:48:14 +0000
**SHA256**: a435ddaa5d35f270f01bb25cf98e994ff8cca0db5fd6eee4e6749831a9186cb8
``````c#ifndef OTA_HANDLER_H
#define OTA_HANDLER_H

// Initialize OTA functionality
void setupOTA();

// Process OTA update events
void handleOTA();

#endif
## `PTZ.cpp`
**Absolute path**: C:\Users\stellaris\Documents\PlatformIO\Projects\ESP32_CAM_AI\src\PTZ.cpp
**Size**: 5454 bytes
**Modified**: 2025-11-09 15:48:14 +0000
**SHA256**: c68acf09eb181690879da6dac2243c436ae017f4176f561ecdbe7be3a4794f60
``````cpp#include "PTZ.h"

#include <ESP32Servo.h>
#include <Preferences.h>
#include <ESPAsyncWebServer.h>

#include "WiFiManager.h"   // isAuthorized(), getWebServer(), ensureWebServerStarted()

// ===== Hardware pins (AI Thinker defaults; change if needed) =====
#ifndef PTZ_SERVO_PAN_PIN
#define PTZ_SERVO_PAN_PIN 14
#endif
#ifndef PTZ_SERVO_TILT_PIN
#define PTZ_SERVO_TILT_PIN 15
#endif

// ===== Limits and defaults =====
static const int kMinDeg = 0;
static const int kMaxDeg = 180;
static const int kStepDefault = 10;

static Servo g_pan;
static Servo g_tilt;

static int g_panDeg = 90;
static int g_tiltDeg = 90;

static Preferences g_prefs; // namespace "ptz"

// Helpers
static inline int clamp(int v, int lo, int hi) {
  if (v < lo) return lo;
  if (v > hi) return hi;
  return v;
}
static void writeServos() {
  g_pan.write(clamp(g_panDeg, kMinDeg, kMaxDeg));
  g_tilt.write(clamp(g_tiltDeg, kMinDeg, kMaxDeg));
}

void ptzInit() {
  // Configure frequency first to avoid jitter
  g_pan.setPeriodHertz(50);
  g_tilt.setPeriodHertz(50);

  // Attach once; on ESP32 you can attach without explicit channel if not used elsewhere
  g_pan.attach(PTZ_SERVO_PAN_PIN, 500, 2500);  // 0..180 -> 0.5..2.5ms
  g_tilt.attach(PTZ_SERVO_TILT_PIN, 500, 2500);

  // Load persisted angles; fall back to 90/90
  g_prefs.begin("ptz", false);
  g_panDeg  = clamp(g_prefs.getInt("pan",  90), kMinDeg, kMaxDeg);
  g_tiltDeg = clamp(g_prefs.getInt("tilt", 90), kMinDeg, kMaxDeg);
  // Optional separate home values; default to current if missing
  int homePan  = g_prefs.getInt("homePan",  g_panDeg);
  int homeTilt = g_prefs.getInt("homeTilt", g_tiltDeg);
  // Ensure current is within range
  g_panDeg  = clamp(g_panDeg,  kMinDeg, kMaxDeg);
  g_tiltDeg = clamp(g_tiltDeg, kMinDeg, kMaxDeg);
  g_prefs.end();

  // Move to current (which equals home on first boot)
  writeServos();

  // Ensure routes exist
  ensureWebServerStarted();
  ptzRegisterRoutes(getWebServer());
}

bool ptzSet(int panDeg, int tiltDeg) {
  int np = clamp(panDeg,  kMinDeg, kMaxDeg);
  int nt = clamp(tiltDeg, kMinDeg, kMaxDeg);
  bool changed = (np != g_panDeg) || (nt != g_tiltDeg);
  g_panDeg = np; g_tiltDeg = nt;
  writeServos();
  // Persist current for warm reboots
  g_prefs.begin("ptz", false);
  g_prefs.putInt("pan", g_panDeg);
  g_prefs.putInt("tilt", g_tiltDeg);
  g_prefs.end();
  return changed;
}

bool ptzStep(int dPan, int dTilt) {
  return ptzSet(g_panDeg + dPan, g_tiltDeg + dTilt);
}

void ptzHome() {
  g_prefs.begin("ptz", true);
  int hp = g_prefs.getInt("homePan",  90);
  int ht = g_prefs.getInt("homeTilt", 90);
  g_prefs.end();
  ptzSet(hp, ht);
}

void ptzSaveHome(int panDeg, int tiltDeg) {
  int np = clamp(panDeg,  kMinDeg, kMaxDeg);
  int nt = clamp(tiltDeg, kMinDeg, kMaxDeg);
  g_prefs.begin("ptz", false);
  g_prefs.putInt("homePan",  np);
  g_prefs.putInt("homeTilt", nt);
  g_prefs.end();
}

void ptzGet(int& panOut, int& tiltOut) {
  panOut = g_panDeg; tiltOut = g_tiltDeg;
}

// ===== HTTP routes (port 80 via AsyncWebServer) =====
static void send401(AsyncWebServerRequest* req) {
  auto* r = req->beginResponse(401, "text/plain", "Unauthorized");
  r->addHeader("WWW-Authenticate", "Basic realm=\"ESP32Cam\"");
  req->send(r);
}

void ptzRegisterRoutes(AsyncWebServer& srv) {
  // Absolute set: /ptz?pan=..&tilt=.. [&savehome=1]
  srv.on("/ptz", HTTP_GET, [](AsyncWebServerRequest* req){
    if (!isAuthorized(req)) { send401(req); return; }
    bool had = false;
    int pan = g_panDeg, tilt = g_tiltDeg;
    if (req->hasParam("pan"))  { pan  = req->getParam("pan")->value().toInt();  had = true; }
    if (req->hasParam("tilt")) { tilt = req->getParam("tilt")->value().toInt(); had = true; }
    if (had) ptzSet(pan, tilt);

    if (req->hasParam("savehome")) {
      ptzSaveHome(g_panDeg, g_tiltDeg);
    }

    int hp=90, ht=90;
    Preferences p; p.begin("ptz", true);
    hp = p.getInt("homePan", 90);
    ht = p.getInt("homeTilt", 90);
    p.end();

    char buf[128];
    snprintf(buf, sizeof(buf),
      "{\"pan\":%d,\"tilt\":%d,\"homePan\":%d,\"homeTilt\":%d}",
      g_panDeg, g_tiltDeg, hp, ht);
    req->send(200, "application/json", buf);
  });

  // Relative step: /ptz/step?dx=..&dy=..
  srv.on("/ptz/step", HTTP_GET, [](AsyncWebServerRequest* req){
    if (!isAuthorized(req)) { send401(req); return; }
    int dx = kStepDefault;
    int dy = 0;
    if (req->hasParam("dx")) dx = req->getParam("dx")->value().toInt();
    if (req->hasParam("dy")) dy = req->getParam("dy")->value().toInt();
    ptzStep(dx, dy);
    char buf[64];
    snprintf(buf, sizeof(buf), "{\"pan\":%d,\"tilt\":%d}", g_panDeg, g_tiltDeg);
    req->send(200, "application/json", buf);
  });

  // Go home: /ptz/home
  srv.on("/ptz/home", HTTP_GET, [](AsyncWebServerRequest* req){
    if (!isAuthorized(req)) { send401(req); return; }
    ptzHome();
    char buf[64];
    snprintf(buf, sizeof(buf), "{\"pan\":%d,\"tilt\":%d}", g_panDeg, g_tiltDeg);
    req->send(200, "application/json", buf);
  });

  // PTZ status: /api/ptz
  srv.on("/api/ptz", HTTP_GET, [](AsyncWebServerRequest* req){
    if (!isAuthorized(req)) { send401(req); return; }
    char buf[64];
    snprintf(buf, sizeof(buf), "{\"pan\":%d,\"tilt\":%d}", g_panDeg, g_tiltDeg);
    req->send(200, "application/json", buf);
  });
}
## `PTZ.h`
**Absolute path**: C:\Users\stellaris\Documents\PlatformIO\Projects\ESP32_CAM_AI\src\PTZ.h
**Size**: 754 bytes
**Modified**: 2025-11-09 15:48:14 +0000
**SHA256**: 16604296e64982264cf054ed43b63f062e64999274d72afbf7bee3a069f188eb
``````c#pragma once
#include <Arduino.h>

class AsyncWebServer;

// Initialise servos, load persisted home/current angles, move to home.
void ptzInit();

// Register all PTZ HTTP routes on the shared AsyncWebServer.
// Safe to call multiple times; it ensures the server exists.
void ptzRegisterRoutes(AsyncWebServer& srv);

// Set absolute angles (0..180). Returns false if clamped or unchanged.
bool ptzSet(int panDeg, int tiltDeg);

// Step by deltas (can be negative). Returns final angles applied.
bool ptzStep(int dPan, int dTilt);

// Reset to persisted home.
void ptzHome();

// Read current angles.
void ptzGet(int& panOut, int& tiltOut);

// Persist the provided angles as new home.
void ptzSaveHome(int panDeg, int tiltDeg);
## `StreamServer.cpp`
**Absolute path**: C:\Users\stellaris\Documents\PlatformIO\Projects\ESP32_CAM_AI\src\StreamServer.cpp
**Size**: 6549 bytes
**Modified**: 2025-11-09 15:48:14 +0000
**SHA256**: 43317e7ad33637d2aa1913a08e9e0c967c87a9b0529b7e127bbc2dc043ed2ae4
``````cpp#include "StreamServer.h"
#include "esp_camera.h"
#include "esp_http_server.h"
#include "WiFiManager.h"

httpd_handle_t stream_httpd = NULL;

// MIME type for MJPEG stream with frame boundary marker
static const char* _STREAM_CONTENT_TYPE = "multipart/x-mixed-replace; boundary=frame";
// Delimiter between JPEG frames in the multipart response
static const char* _STREAM_BOUNDARY = "\r\n--frame\r\n";
// Template for each part's headers indicating JPEG data and its length
static const char* _STREAM_PART = "Content-Type: image/jpeg\r\nContent-Length: %u\r\n\r\n";

static esp_err_t stream_handler(httpd_req_t *req) {
  camera_fb_t *fb = NULL;
  esp_err_t res = ESP_OK;
  char part_buf[64];

  // Authorization: allow Basic header or ?token= param
  if (isAuthEnabled()) {
    bool ok = false;
    // Check token in query string
    int ql = httpd_req_get_url_query_len(req);
    if (ql > 0) {
      char* q = (char*)malloc(ql+1);
      if (!q) return ESP_ERR_NO_MEM;
      if (httpd_req_get_url_query_str(req, q, ql+1) == ESP_OK) {
        char tbuf[128];
        if (httpd_query_key_value(q, "token", tbuf, sizeof(tbuf)) == ESP_OK) {
          ok = isValidTokenParam(tbuf);
        }
      }
      free(q);
    }
    // Check Basic header if not ok yet
    if (!ok) {
      size_t alen = httpd_req_get_hdr_value_len(req, "Authorization");
      if (alen > 0) {
        char* abuf = (char*)malloc(alen+1);
        if (!abuf) return ESP_ERR_NO_MEM;
        if (httpd_req_get_hdr_value_str(req, "Authorization", abuf, alen+1) == ESP_OK) {
          ok = isAuthorizedBasicHeader(abuf);
        }
        free(abuf);
      }
    }
    if (!ok) {
      httpd_resp_set_status(req, "401 Unauthorized");
      httpd_resp_set_hdr(req, "WWW-Authenticate", "Basic realm=\"ESP32Cam\"");
      httpd_resp_set_type(req, "text/plain");
      httpd_resp_send(req, "Unauthorized", HTTPD_RESP_USE_STRLEN);
      return ESP_OK;
    }
  }

  // Tell the client to expect multipart MJPEG stream + friendly headers
  httpd_resp_set_hdr(req, "Cache-Control", "no-store, no-cache, must-revalidate, max-age=0");
  httpd_resp_set_hdr(req, "Pragma", "no-cache");
  httpd_resp_set_hdr(req, "Access-Control-Allow-Origin", "*");
  res = httpd_resp_set_type(req, _STREAM_CONTENT_TYPE);
  if (res != ESP_OK) return res;

  while (true) {
    // Grab a frame from the camera
    fb = esp_camera_fb_get();
    if (!fb) {
      res = ESP_FAIL;
      break;
    }

    // Prepare JPEG buffer
    const uint8_t* buf = nullptr;
    size_t len = 0;
    uint8_t* jpg_buf = nullptr;
    size_t jpg_len = 0;

    if (fb->format == PIXFORMAT_JPEG) {
      buf = fb->buf;
      len = fb->len;
    } else {
      // Convert frame buffer to JPEG if not already
      bool ok = frame2jpg(fb, 80, &jpg_buf, &jpg_len);
      if (!ok) {
        esp_camera_fb_return(fb);
        res = ESP_FAIL;
        break;
      }
      buf = jpg_buf;
      len = jpg_len;
    }

    // Send the JPEG as a multipart HTTP response:
    // first the part header, then the image data, then the boundary marker
    size_t hlen = snprintf(part_buf, sizeof(part_buf), _STREAM_PART, (unsigned)len);
    res = httpd_resp_send_chunk(req, part_buf, hlen);
    if (res == ESP_OK)
      res = httpd_resp_send_chunk(req, (const char*)buf, len);
    if (res == ESP_OK)
      res = httpd_resp_send_chunk(req, _STREAM_BOUNDARY, strlen(_STREAM_BOUNDARY));

    // Return/free buffers
    if (fb) {
      esp_camera_fb_return(fb);
      fb = NULL;
    }
    if (jpg_buf) {
      free(jpg_buf);
      jpg_buf = NULL;
    }

    if (res != ESP_OK) break;
  }

  return res;
}

// Snapshot endpoint for quick diagnostics
static esp_err_t snapshot_handler(httpd_req_t *req) {
  if (isAuthEnabled()) {
    bool ok = false;
    int ql = httpd_req_get_url_query_len(req);
    if (ql > 0) {
      char* q = (char*)malloc(ql+1);
      if (!q) return ESP_ERR_NO_MEM;
      if (httpd_req_get_url_query_str(req, q, ql+1) == ESP_OK) {
        char tbuf[128];
        if (httpd_query_key_value(q, "token", tbuf, sizeof(tbuf)) == ESP_OK) {
          ok = isValidTokenParam(tbuf);
        }
      }
      free(q);
    }
    if (!ok) {
      size_t alen = httpd_req_get_hdr_value_len(req, "Authorization");
      if (alen > 0) {
        char* abuf = (char*)malloc(alen+1);
        if (!abuf) return ESP_ERR_NO_MEM;
        if (httpd_req_get_hdr_value_str(req, "Authorization", abuf, alen+1) == ESP_OK) {
          ok = isAuthorizedBasicHeader(abuf);
        }
        free(abuf);
      }
    }
    if (!ok) {
      httpd_resp_set_status(req, "401 Unauthorized");
      httpd_resp_set_hdr(req, "WWW-Authenticate", "Basic realm=\"ESP32Cam\"");
      httpd_resp_set_type(req, "text/plain");
      httpd_resp_send(req, "Unauthorized", HTTPD_RESP_USE_STRLEN);
      return ESP_OK;
    }
  }
  camera_fb_t* fb = esp_camera_fb_get();
  if (!fb) {
    httpd_resp_set_status(req, "503 Service Unavailable");
    httpd_resp_set_type(req, "text/plain");
    httpd_resp_send(req, "Camera unavailable", HTTPD_RESP_USE_STRLEN);
    return ESP_OK;
  }
  const uint8_t* img = nullptr; size_t len = 0; uint8_t* jpg_buf = nullptr; size_t jpg_len = 0;
  if (fb->format == PIXFORMAT_JPEG) { img = fb->buf; len = fb->len; }
  else {
    if (!frame2jpg(fb, 80, &jpg_buf, &jpg_len)) { esp_camera_fb_return(fb); return ESP_FAIL; }
    img = jpg_buf; len = jpg_len;
  }
  httpd_resp_set_type(req, "image/jpeg");
  httpd_resp_send(req, (const char*)img, len);
  if (jpg_buf) free(jpg_buf);
  esp_camera_fb_return(fb);
  return ESP_OK;
}

/**
 * Start HTTP server dedicated to MJPEG streaming.
 * Uses port 81 and registers stream_handler for the "/stream" URI.
 */
void startStreamServer() {
  httpd_config_t config = HTTPD_DEFAULT_CONFIG();
  config.server_port = 81; // Use a port different from the main web server

  httpd_uri_t stream_uri = {
    .uri       = "/stream",
    .method    = HTTP_GET,
    .handler   = stream_handler,
    .user_ctx  = NULL
  };

  if (httpd_start(&stream_httpd, &config) == ESP_OK) {
    // Register handler that serves the stream when /stream is requested
    httpd_register_uri_handler(stream_httpd, &stream_uri);
    // Also provide /snap for quick diagnostics
    httpd_uri_t snap_uri = { .uri = "/snap", .method = HTTP_GET, .handler = snapshot_handler, .user_ctx = NULL };
    httpd_register_uri_handler(stream_httpd, &snap_uri);
  }
}
## `StreamServer.h`
**Absolute path**: C:\Users\stellaris\Documents\PlatformIO\Projects\ESP32_CAM_AI\src\StreamServer.h
**Size**: 41 bytes
**Modified**: 2025-11-09 15:48:14 +0000
**SHA256**: fff3c163400dd12f9a360984776df7675f26958cfaf5dd7be0a7f7f1363d2afd
``````c#pragma once
void startStreamServer();
## `Utils.cpp`
**Absolute path**: C:\Users\stellaris\Documents\PlatformIO\Projects\ESP32_CAM_AI\src\Utils.cpp
**Size**: 433 bytes
**Modified**: 2025-11-09 15:48:14 +0000
**SHA256**: 22ac9a31ac91a818d4c55ccd8a35954483cf51fed7de41cee885336d8f138020
``````cpp#include "Utils.h"
#include "soc/soc.h"
#include "soc/rtc_cntl_reg.h"



void disableBrownout() {
  // The ESP32-CAM is sensitive to brief voltage drops when peripherals
  // such as the camera or servos draw peak current. Those dips can
  // trigger the on-chip brownout detector and cause an unexpected
  // reset, so the detector is disabled to keep the device running.
  WRITE_PERI_REG(RTC_CNTL_BROWN_OUT_REG, 0);
}
## `Utils.h`
**Absolute path**: C:\Users\stellaris\Documents\PlatformIO\Projects\ESP32_CAM_AI\src\Utils.h
**Size**: 414 bytes
**Modified**: 2025-11-09 15:48:14 +0000
**SHA256**: ee0d09c331ed354605c2d82d4c3dac479fa5e1c90cb05c67c6482e8fa6c698d0
``````c#ifndef UTILS_H
#define UTILS_H

#include <ESP32Servo.h>

/**
 * Globals for servo control. Defined in Utils.cpp to guarantee
 * construction order before any call to setupServos().
 */
extern Servo servo1;
extern Servo servo2;

/**
 * Disable the ESP32's brownout detector to prevent unwanted resets
 * during brief voltage dips caused by high current draw.
 */
void disableBrownout();

#endif
## `WiFiConfigPortal.cpp`
**Absolute path**: C:\Users\stellaris\Documents\PlatformIO\Projects\ESP32_CAM_AI\src\WiFiConfigPortal.cpp
**Size**: 4077 bytes
**Modified**: 2025-11-09 22:51:00 +0000
**SHA256**: caf41c488472c8a70225164fb3634df382c4bda6add05ccf4ffcd05412c68928
``````cpp// src/WiFiConfigPortal.cpp

#include <Arduino.h>
#include <WiFi.h>
#include <Preferences.h>
#include <WebServer.h>
#include "WiFiManager.h"

// Blocking AP-mode config portal runs in its own task on core 0
static WebServer   cfgServer(80);
static Preferences cfgPrefs;

static const char* kStyle = R"CSS(
  <style>
    body{font-family:system-ui,Arial,sans-serif;margin:0;padding:0;background:#eef3fb;color:#102a43}
    .wrap{max-width:780px;margin:20px auto;padding:0 12px}
    .panel{background:#ffffff;border-radius:10px;padding:14px 16px;margin:0 0 14px 0;
           box-shadow:0 1px 4px rgba(0,0,0,.08)}
    .row{display:flex;flex-wrap:wrap;align-items:center;margin:6px 0;gap:8px}
    label{min-width:110px;font-weight:600}
    input[type=text],input[type=password]{flex:1 1 200px;padding:6px 8px;border-radius:6px;border:1px solid #cbd2e6}
    .btn{display:inline-block;padding:6px 10px;border-radius:6px;border:1px solid #cbd2e6;
         background:#dde7ff;text-decoration:none;color:#102a43;cursor:pointer}
    .hint{font-size:.85rem;color:#62718a}
  </style>
)CSS";

// Core-0 task that actually runs the portal
static void cfgPortalTask(void* arg) {
  (void)arg;
  Serial.println("cfgPortalTask: starting (core 0)");

  // Clean up any previous STA attempts
  WiFi.disconnect(true);
  delay(200);
  WiFi.mode(WIFI_OFF);
  delay(200);

  WiFi.mode(WIFI_AP);
  String apName = "ESP32Cam-Setup";
  WiFi.softAP(apName.c_str());
  IPAddress apIP = WiFi.softAPIP();
  Serial.printf("AP started: %s  IP: %s\n", apName.c_str(), apIP.toString().c_str());

  cfgServer.on("/", HTTP_GET, []() {
    String html;
    html.reserve(2048);
    html += "<!doctype html><html><head><meta charset='utf-8'><title>ESP32-CAM WiFi Setup</title>";
    html += kStyle;
    html += "</head><body><div class='wrap'><div class='panel'><h3>WiFi Setup</h3>";
    html += "<form method='POST' action='/save'>";
    html += "<div class='row'><label>SSID</label><input name='ssid' type='text' required></div>";
    html += "<div class='row'><label>Password</label><input name='pass' type='password'></div>";
    html += "<div class='row'><button class='btn' type='submit'>Save &amp; Reboot</button></div>";
    html += "<div class='row hint'>After reboot the camera will try this network in STA mode. ";
    html += "Use the /wifi page on its IP for advanced settings.</div>";
    html += "</form></div></div></body></html>";
    cfgServer.send(200, "text/html", html);
  });

  cfgServer.on("/save", HTTP_POST, []() {
    String ssid = cfgServer.arg("ssid");
    String pass = cfgServer.arg("pass");
    if (ssid.isEmpty()) {
      cfgServer.send(400, "text/plain", "SSID required");
      return;
    }

    // Write legacy keys; WiFiManager will read them as MRU[0] on next boot
    cfgPrefs.begin("wifi", false);
    cfgPrefs.putString("ssid", ssid);
    cfgPrefs.putString("pass", pass);
    cfgPrefs.end();

    cfgServer.send(200, "text/html",
                   "<html><body><div class='wrap'><div class='panel'><h3>Saved</h3>"
                   "<div class='row hint'>Credentials saved. Rebooting…</div>"
                   "</div></div></body></html>");
    delay(500);
    ESP.restart();
  });

  cfgServer.begin();
  Serial.println("Config portal started (core 0, blocking loop)");

  // Blocking loop on core 0; core 1 is free to idle
  while (true) {
    cfgServer.handleClient();
    delay(10);
  }
}

// Public API called from setup() on core 1
void startConfigPortal() {
  Serial.println("startConfigPortal: creating cfgPortalTask on core 0");

  xTaskCreatePinnedToCore(
    cfgPortalTask,      // task function
    "cfgPortal",        // name
    4096,               // stack size
    nullptr,            // arg
    1,                  // priority
    nullptr,            // handle
    0                   // core 0
  );

  // Return to caller; core 1 will drop into loop() (usually idle if no OTA),
  // so TG1 WDT is satisfied while AP + portal run on core 0.
}
## `WiFiManager.cpp`
**Absolute path**: C:\Users\stellaris\Documents\PlatformIO\Projects\ESP32_CAM_AI\src\WiFiManager.cpp
**Size**: 13744 bytes
**Modified**: 2025-11-09 22:44:41 +0000
**SHA256**: 778e7b290d952777a38e67545b921d8e7caa9b77b31cf158a1108ce780da759d
``````cpp#include "WiFiManager.h"
#include <WiFi.h>
#include <Preferences.h>
#include <ESPAsyncWebServer.h>

// ===== Globals =====

static bool           g_serverStarted   = false;
static AsyncWebServer g_server(80);

static Preferences    g_prefs;
static String         g_ssid;
static String         g_pass;

static bool           g_useStaticIP = false;
static String         g_ipStr, g_gwStr, g_snStr, g_dnsStr;

static const int      MAX_CONNECT_ATTEMPTS = 20;
static const int      MRU_MAX              = 5;

// ===== Small CSS used on /wifi page =====

static const char* kStyle = R"CSS(
  <style>
    body{font-family:system-ui,Arial,sans-serif;margin:0;padding:0;background:#eef3fb;color:#102a43}
    .wrap{max-width:780px;margin:20px auto;padding:0 12px}
    .panel{background:#ffffff;border-radius:10px;padding:14px 16px;margin:0 0 14px 0;
           box-shadow:0 1px 4px rgba(0,0,0,.08)}
    .row{display:flex;flex-wrap:wrap;align-items:center;margin:6px 0;gap:8px}
    label{min-width:110px;font-weight:600}
    input[type=text],input[type=password]{flex:1 1 200px;padding:6px 8px;border-radius:6px;border:1px solid #cbd2e6}
    .btn{display:inline-block;padding:6px 10px;border-radius:6px;border:1px solid #cbd2e6;
         background:#dde7ff;text-decoration:none;color:#102a43;cursor:pointer}
    .btn.danger{background:#ffd9d9;border-color:#ffc5c5}
    .hint{font-size:.85rem;color:#62718a}
    .mono{font-family:ui-monospace,Menlo,Consolas,monospace}
  </style>
)CSS";

// ===== MRU helpers =====

static void loadMRU(String ssids[], String passes[], int& count) {
  count = 0;
  g_prefs.begin("wifi", true);
  for (int i = 0; i < MRU_MAX; ++i) {
    String skey = String("ssid") + i;
    String pkey = String("pass") + i;
    String s = g_prefs.getString(skey.c_str(), String());
    String p = g_prefs.getString(pkey.c_str(), String());
    if (s.length() > 0) {
      ssids[count]  = s;
      passes[count] = p;
      ++count;
    }
  }
  // Backward compat: legacy single key
  if (count == 0) {
    String s = g_prefs.getString("ssid", "");
    String p = g_prefs.getString("pass", "");
    if (s.length() > 0) {
      ssids[0]  = s;
      passes[0] = p;
      count     = 1;
    }
  }
  g_prefs.end();
}

static void saveMRUList(const String ssids[], const String passes[], int count) {
  g_prefs.begin("wifi", false);
  for (int i = 0; i < MRU_MAX; ++i) {
    String skey = String("ssid") + i;
    String pkey = String("pass") + i;
    if (i < count) {
      g_prefs.putString(skey.c_str(), ssids[i]);
      g_prefs.putString(pkey.c_str(), passes[i]);
    } else {
      g_prefs.putString(skey.c_str(), String());
      g_prefs.putString(pkey.c_str(), String());
    }
  }
  g_prefs.putString("ssid", count > 0 ? ssids[0] : "");
  g_prefs.putString("pass", count > 0 ? passes[0] : "");
  g_prefs.end();
}

static void mruInsertFrontUnique(String ssids[], String passes[], int& count,
                                 const String& s, const String& p) {
  int found = -1;
  for (int i = 0; i < count; ++i) {
    if (ssids[i] == s) {
      found = i;
      break;
    }
  }
  if (found >= 0) {
    for (int i = found; i < count - 1; ++i) {
      ssids[i]  = ssids[i+1];
      passes[i] = passes[i+1];
    }
    --count;
  }
  for (int i = min(count, MRU_MAX-1); i > 0; --i) {
    ssids[i]  = ssids[i-1];
    passes[i] = passes[i-1];
  }
  ssids[0]  = s;
  passes[0] = p;
  if (count < MRU_MAX) ++count;
}

static void saveCreds(const String& s, const String& p) {
  String ssids[MRU_MAX];
  String passes[MRU_MAX];
  int    n = 0;
  loadMRU(ssids, passes, n);
  mruInsertFrontUnique(ssids, passes, n, s, p);
  saveMRUList(ssids, passes, n);
}

// ===== Auth stubs =====

bool isAuthEnabled() {
  return false;
}

bool isValidTokenParam(const char* /*token*/) {
  return true;
}

bool isAuthorizedBasicHeader(const char* /*header*/) {
  return true;
}

String getAuthTokenParam() {
  return String();
}

bool isAuthorized(AsyncWebServerRequest* /*req*/) {
  return true;
}

static bool isAuthorizedOrAP(AsyncWebServerRequest* req) {
  if (WiFi.getMode() & WIFI_AP) return true;
  return isAuthorized(req);
}

// ===== Stored network + static IP =====

static void loadStoredNetworkSettings() {
  String ssids[MRU_MAX];
  String passes[MRU_MAX];
  int    n = 0;
  loadMRU(ssids, passes, n);
  g_ssid = (n > 0) ? ssids[0] : String();
  g_pass = (n > 0) ? passes[0] : String();

  g_prefs.begin("wifi", true);
  g_useStaticIP = g_prefs.getBool("static", false);
  g_ipStr       = g_prefs.getString("ip",  "");
  g_gwStr       = g_prefs.getString("gw",  "");
  g_snStr       = g_prefs.getString("sn",  "");
  g_dnsStr      = g_prefs.getString("dns", "");
  g_prefs.end();
}

static void saveNetworkSettings(const String& ssid,
                                const String& pass,
                                bool useStatic,
                                const String& ip,
                                const String& gw,
                                const String& sn,
                                const String& dns) {
  saveCreds(ssid, pass);
  g_prefs.begin("wifi", false);
  g_prefs.putBool("static", useStatic);
  g_prefs.putString("ip",  ip);
  g_prefs.putString("gw",  gw);
  g_prefs.putString("sn",  sn);
  g_prefs.putString("dns", dns);
  g_prefs.end();
}

// ===== Public: shared AsyncWebServer =====

AsyncWebServer& getWebServer() {
  return g_server;
}

// Forward-declare
static void registerWiFiRoutes();

// ===== Ensure AsyncWebServer started (STA mode) =====

void ensureWebServerStarted() {
  if (g_serverStarted) return;

  g_server.on("/ping", HTTP_GET, [](AsyncWebServerRequest* req){
    req->send(200, "text/plain", "pong");
  });

  registerWiFiRoutes();

  g_server.begin();
  g_serverStarted = true;

  IPAddress ip = (WiFi.status() == WL_CONNECTED) ? WiFi.localIP() : WiFi.softAPIP();
  Serial.printf("Web UI:    http://%s/  (try /ping)\n", ip.toString().c_str());
}

// ===== Connect to stored Wi-Fi (STA) =====

bool connectToStoredWiFi() {
  loadStoredNetworkSettings();

  String ssids[MRU_MAX];
  String passes[MRU_MAX];
  int    n = 0;
  loadMRU(ssids, passes, n);
  if (n == 0) return false;

  WiFi.mode(WIFI_STA);

  if (g_useStaticIP) {
    IPAddress ip, gw, sn, dns;
    bool ok = ip.fromString(g_ipStr) &&
              gw.fromString(g_gwStr) &&
              sn.fromString(g_snStr);
    if (!dns.fromString(g_dnsStr)) dns = gw;
    if (ok) {
      Serial.printf("Using static IP: %s gw %s sn %s dns %s\n",
                    ip.toString().c_str(), gw.toString().c_str(),
                    sn.toString().c_str(), dns.toString().c_str());
      WiFi.config(ip, gw, sn, dns);
    } else {
      Serial.println("Static IP config invalid; falling back to DHCP");
    }
  }

  for (int i = 0; i < n; ++i) {
    const String& s = ssids[i];
    const String& p = passes[i];
    if (s.isEmpty()) continue;

    Serial.printf("Connecting to %s", s.c_str());
    WiFi.begin(s.c_str(), p.c_str());

    int attempts = 0;
    while (WiFi.status() != WL_CONNECTED && attempts < MAX_CONNECT_ATTEMPTS) {
      delay(300);
      Serial.print(".");
      ++attempts;
    }
    Serial.println();

    if (WiFi.status() == WL_CONNECTED) {
      Serial.printf("Connected: %s\n", WiFi.localIP().toString().c_str());
      if (i != 0) {
        mruInsertFrontUnique(ssids, passes, n, s, p);
        saveMRUList(ssids, passes, n);
      }
      g_ssid = ssids[0];
      g_pass = passes[0];
      return true;
    }

    WiFi.disconnect(true);
    delay(200);
  }

  return false;
}

// ===== /wifi page (STA, AsyncWebServer) =====

static String htmlEscape(const String& s) {
  String o; o.reserve(s.length() + 8);
  for (size_t i = 0; i < s.length(); ++i) {
    char c = s[i];
    if      (c == '&')  o += "&amp;";
    else if (c == '<')  o += "&lt;";
    else if (c == '>')  o += "&gt;";
    else if (c == '\"') o += "&quot;";
    else if (c == '\'') o += "&#39;";
    else                o += c;
  }
  return o;
}

static void renderWiFiPage(AsyncWebServerRequest* req) {
  loadStoredNetworkSettings();

  String html;
  html.reserve(4096);
  html += "<!doctype html><html><head><meta charset='utf-8'><title>ESP32-CAM • Wi-Fi</title>";
  html += kStyle;
  html += "</head><body><div class='wrap'>";

  html += "<div class='panel'><h3>Wi-Fi Settings</h3>";
  html += "<div class='row hint'>Mode: <b>";
  if (WiFi.getMode() & WIFI_AP) html += "Access Point";
  else                          html += "Station";
  html += "</b></div>";

  html += "<div class='row hint'>Device IP: <span class='mono'><b>";
  if (WiFi.status() == WL_CONNECTED) html += WiFi.localIP().toString();
  else                               html += WiFi.softAPIP().toString();
  html += "</b></span></div>";
  html += "</div>";

  html += "<div class='panel'><h3>Credentials</h3>";
  html += "<form method='POST' action='/wifi/save'>";
  html += "<div class='row'><label for='ssid'>SSID</label>";
  html += "<input id='ssid' name='ssid' type='text' value='" + htmlEscape(g_ssid) + "' required></div>";
  html += "<div class='row'><label for='pass'>Password</label>";
  html += "<input id='pass' name='pass' type='password' value='" + htmlEscape(g_pass) + "'></div>";
  html += "<div class='row'><label for='ustatic'>Use Static IP</label>";
  html += "<input id='ustatic' name='ustatic' type='checkbox' ";
  if (g_useStaticIP) html += "checked";
  html += "></div>";
  html += "<div class='row'><label>IP</label><input name='ip' type='text' value='" + htmlEscape(g_ipStr)  + "'></div>";
  html += "<div class='row'><label>Gateway</label><input name='gw' type='text' value='" + htmlEscape(g_gwStr) + "'></div>";
  html += "<div class='row'><label>Subnet</label><input name='sn' type='text' value='" + htmlEscape(g_snStr) + "'></div>";
  html += "<div class='row'><label>DNS</label><input name='dns' type='text' value='" + htmlEscape(g_dnsStr) + "'></div>";
  html += "<div class='row'><button class='btn' type='submit'>Save &amp; Reboot</button>";
  html += "<a class='btn danger' href='/wifi/reboot'>Reboot</a></div>";
  html += "</form></div>";

  String ssids[MRU_MAX]; String passes[MRU_MAX]; int n = 0;
  loadMRU(ssids, passes, n);
  html += "<div class='panel'><h3>Known Networks</h3>";
  if (n == 0) {
    html += "<div class='row hint'>No saved networks yet.</div>";
  } else {
    for (int i = 0; i < n; ++i) {
      html += "<div class='row'><label>";
      html += String(i+1);
      html += ".</label><span class='mono'>" + htmlEscape(ssids[i]) + "</span>";
      if (i == 0) html += " <b>(current)</b>";
      html += "</div>";
    }
  }
  html += "</div>";

  html += "</div></body></html>";
  req->send(200, "text/html", html);
}

static void registerWiFiRoutes() {
  g_server.on("/wifi", HTTP_GET, [](AsyncWebServerRequest* req){
    if (!isAuthorizedOrAP(req)) {
      auto* r = req->beginResponse(401, "text/plain", "Unauthorized");
      r->addHeader("WWW-Authenticate", "Basic realm=\"ESP32Cam\"");
      req->send(r);
      return;
    }
    renderWiFiPage(req);
  });

  g_server.on("/wifi/save", HTTP_POST, [](AsyncWebServerRequest* req){
    if (!isAuthorizedOrAP(req)) {
      auto* r = req->beginResponse(401, "text/plain", "Unauthorized");
      r->addHeader("WWW-Authenticate", "Basic realm=\"ESP32Cam\"");
      req->send(r);
      return;
    }

    String ssid = req->hasParam("ssid", true) ? req->getParam("ssid", true)->value() : String();
    String pass = req->hasParam("pass", true) ? req->getParam("pass", true)->value() : String();
    bool   useStatic = req->hasParam("ustatic", true);
    String ip  = req->hasParam("ip",  true) ? req->getParam("ip",  true)->value() : String();
    String gw  = req->hasParam("gw",  true) ? req->getParam("gw",  true)->value() : String();
    String sn  = req->hasParam("sn",  true) ? req->getParam("sn",  true)->value() : String();
    String dns = req->hasParam("dns", true) ? req->getParam("dns", true)->value() : String();

    if (ssid.isEmpty()) {
      req->send(400, "text/plain", "SSID required");
      return;
    }

    saveNetworkSettings(ssid, pass, useStatic, ip, gw, sn, dns);

    String html;
    html.reserve(1024);
    html += "<!doctype html><html><head><meta charset='utf-8'><title>Saved</title>";
    html += kStyle;
    html += "<meta http-equiv='refresh' content='3;url=/wifi'>";
    html += "</head><body><div class='wrap'>";
    html += "<div class='panel'><h3>Saved</h3><div class='row hint'>Credentials saved. Rebooting…</div></div>";
    html += "</div></body></html>";
    req->send(200, "text/html", html);

    delay(500);
    ESP.restart();
  });

  g_server.on("/wifi/reboot", HTTP_GET, [](AsyncWebServerRequest* req){
    if (!isAuthorizedOrAP(req)) {
      auto* r = req->beginResponse(401, "text/plain", "Unauthorized");
      r->addHeader("WWW-Authenticate", "Basic realm=\"ESP32Cam\"");
      req->send(r);
      return;
    }
    String html;
    html.reserve(512);
    html += "<!doctype html><html><head><meta charset='utf-8'><title>Rebooting</title>";
    html += kStyle;
    html += "</head><body><div class='wrap'><div class='panel'><h3>Rebooting…</h3>";
    html += "<div class='row hint'>Device is rebooting.</div></div></div></body></html>";
    req->send(200, "text/html", html);
    delay(300);
    ESP.restart();
  });
}

// NOTE: startConfigPortal() is implemented in WiFiConfigPortal.cpp## `WiFiManager.h`
**Absolute path**: C:\Users\stellaris\Documents\PlatformIO\Projects\ESP32_CAM_AI\src\WiFiManager.h
**Size**: 827 bytes
**Modified**: 2025-11-09 22:44:20 +0000
**SHA256**: 8ac005a0a777dcbb6b9fdd92adbe09e73f9e8b53c1315dd64b4c809e312d648b
``````c#ifndef WIFI_MANAGER_H
#define WIFI_MANAGER_H

#include <Arduino.h>

// Forward-declare AsyncWebServer without pulling in its header here
class AsyncWebServer;
class AsyncWebServerRequest;

// Shared Async web server (STA mode)
AsyncWebServer& getWebServer();

// Start Async web server if not already running (STA mode only)
void ensureWebServerStarted();

// Wi-Fi connect using stored MRU / static IP
bool connectToStoredWiFi();

// Start AP-mode config portal (blocking, implemented in WiFiConfigPortal.cpp)
void startConfigPortal();

// Authentication helpers (API preserved, currently no auth)
bool isAuthEnabled();
bool isAuthorized(AsyncWebServerRequest* req);
bool isAuthorizedBasicHeader(const char* header);
bool isValidTokenParam(const char* token);
String getAuthTokenParam();

#endif
